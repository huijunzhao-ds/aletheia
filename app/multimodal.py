# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import uuid
import logging
from gtts import gTTS
from pptx import Presentation
from pptx.util import Inches, Pt
from typing import List, Dict

logger = logging.getLogger(__name__)

AUDIO_DIR = "static/audio"

def generate_audio_file(text: str, schema: str = "en") -> str:
    """
    Generates an audio file from text using gTTS.
    
    Args:
        text: The text to convert to speech.
        schema: Language code (default 'en').
        
    Returns:
        The relative path to the generated audio file.
    """
    try:
        # Ensure directory exists
        os.makedirs(AUDIO_DIR, exist_ok=True)
        
        # Generate unique filename
        filename = f"{uuid.uuid4()}.mp3"
        filepath = os.path.join(AUDIO_DIR, filename)
        
        # Generate audio
        tts = gTTS(text=text, lang=schema)
        tts.save(filepath)
        
        logger.info(f"Generated audio file: {filepath}")
        return filepath
    except Exception as e:
        logger.error(f"Error generating audio: {e}")
        raise

SLIDES_DIR = "static/slides"

def generate_presentation(title: str, slides_content: List[Dict[str, str]]) -> str:
    """
    Generates a PowerPoint presentation.
    
    Args:
        title: The title of the presentation.
        slides_content: A list of dicts, each with 'title' and 'content' keys.
        
    Returns:
        The relative path to the generated .pptx file.
    """
    try:
        os.makedirs(SLIDES_DIR, exist_ok=True)
        
        prs = Presentation()
        
        # Title Slide
        title_slide_layout = prs.slide_layouts[0]
        slide = prs.slides.add_slide(title_slide_layout)
        title_placeholder = slide.shapes.title
        subtitle_placeholder = slide.placeholders[1]
        
        title_placeholder.text = title
        subtitle_placeholder.text = "Generated by AI Research Assistant"
        
        # Content Slides
        bullet_slide_layout = prs.slide_layouts[1]
        
        for slide_data in slides_content:
            slide = prs.slides.add_slide(bullet_slide_layout)
            shapes = slide.shapes
            
            title_shape = shapes.title
            body_shape = shapes.placeholders[1]
            
            title_shape.text = slide_data.get("title", "Untitled Slide")
            tf = body_shape.text_frame
            tf.text = slide_data.get("content", "")
            
        filename = f"{uuid.uuid4()}.pptx"
        filepath = os.path.join(SLIDES_DIR, filename)
        prs.save(filepath)
        
        logger.info(f"Generated presentation: {filepath}")
        return filepath
        
    except Exception as e:
        return filepath
        
    except Exception as e:
        logger.error(f"Error generating presentation: {e}")
        raise

VIDEO_DIR = "static/videos"

from moviepy import ImageClip, AudioFileClip, concatenate_videoclips
from PIL import Image, ImageDraw, ImageFont

def create_slide_image(title: str, content: str, filename: str):
    """Creates a simple slide image using Pillow."""
    width = 1280
    height = 720
    background_color = (255, 255, 255)
    text_color = (0, 0, 0)
    
    img = Image.new('RGB', (width, height), color=background_color)
    d = ImageDraw.Draw(img)
    
    # Simple layout (fonts might need adjustment on different systems)
    # Using default font for simplicity in this environment
    
    # Title
    d.text((50, 50), title, fill=text_color)
    
    # Content (naive text wrapping)
    y_text = 150
    lines = content.split('\n')
    for line in lines:
        # Very basic wrapping simulator or just printing split lines
        # In a real app we'd use a better text wrapper
        d.text((50, y_text), line, fill=text_color)
        y_text += 40
        
    img.save(filename)

def generate_video_lecture(title: str, slides_content: List[Dict[str, str]]) -> str:
    """
    Generates an MP4 video lecture.
    
    Args:
        title: Title of the lecture.
        slides_content: List of dicts with 'title' and 'content'.
                        Content is spoken AND shown.
    
    Returns:
        Path to video file.
    """
    try:
        os.makedirs(VIDEO_DIR, exist_ok=True)
        clips = []
        
        # 1. Title Sequence
        title_img_path = os.path.join(VIDEO_DIR, f"{uuid.uuid4()}_title.png")
        create_slide_image(title, "AI Research Assistant Presentation", title_img_path)
        
        # Intro Audio
        intro_audio_path = generate_audio_file(f"Welcome to the lecture on {title}")
        
        # Combine
        # Using context managers or direct load/close is safer but eager loading for now
        audio_clip = AudioFileClip(intro_audio_path)
        img_clip = ImageClip(title_img_path).with_duration(audio_clip.duration)
        img_clip = img_clip.with_audio(audio_clip)
        clips.append(img_clip)
        
        # 2. Content Slides
        for slide in slides_content:
            slide_title = slide.get("title", "")
            slide_text = slide.get("content", "")
            
            # Image
            img_path = os.path.join(VIDEO_DIR, f"{uuid.uuid4()}_slide.png")
            create_slide_image(slide_title, slide_text, img_path)
            
            # Audio (Agent speaks the content)
            # Note: For better UX, we might want a 'script' field separate from 'content'
            # creating a smoother narration. For now, reading content.
            audio_path = generate_audio_file(slide_text)
            
            slide_audio = AudioFileClip(audio_path)
            slide_clip = ImageClip(img_path).with_duration(slide_audio.duration)
            slide_clip = slide_clip.with_audio(slide_audio)
            clips.append(slide_clip)
            
        # 3. Concatenate
        final_clip = concatenate_videoclips(clips)
        output_filename = f"{uuid.uuid4()}.mp4"
        output_path = os.path.join(VIDEO_DIR, output_filename)
        
        final_clip.write_videofile(output_path, fps=24, codec='libx264')
        
        # Cleanup temp files could happen here
        
        logger.info(f"Generated video: {output_path}")
        return output_path

    except Exception as e:
        logger.error(f"Error generating video: {e}")
        raise
